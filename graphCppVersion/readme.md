## [1 . Graph as input in the form of an adjacency matrix ](https://github.com/BibhabenduMukherjee/Graphs/blob/main/graphCppVersion/GraphInputAdjMatrix.cpp)
An adjacency matrix of a graph is a two-dimensional array of size n x n, where n is the number of nodes in the graph, with the property that a[ i ][ j ] = 1 if the edge (vᵢ, vⱼ) is in the set of edges, and a[ i ][ j ] = 0 if there is no such edge



![Animated Gif](https://lh6.googleusercontent.com/RJXRgXqBBveetZajhikyA8q29MhMzKKDUXH0WuQb9-k7owhUIi6rZxqvyU-gNicg7HqRYHOE44_C5ojbCpQlbi0QDIn2ZuwWUA6LD5wYSWz6ehdDthINzqofzZ5NZJyEbShmYhJmn7j7IZFlhvyh_uY)


## [2. BFS Traversal ](https://github.com/BibhabenduMukherjee/Graphs/blob/main/graphCppVersion/BfsTraversal.cpp)

BFS, or Breadth-First Search, is a powerful algorithm used to traverse or search tree and graph data structures. It prioritizes exploring all the direct neighbors of a node before moving on to the next level. Imagine exploring a maze by visiting all the rooms connected to the current one before venturing further down any corridors.


## [3. DFS Traversal ](https://github.com/BibhabenduMukherjee/Graphs/blob/main/graphCppVersion/DfsTraversal.cpp)

DFS, or Depth-First Search, is another powerful algorithm for traversing or searching tree and graph data structures. Unlike BFS, it prioritizes exploring one branch as deep as possible before backtracking and considering other options. Imagine exploring a maze by venturing down a single path until you reach a dead end, then backtracking and trying another path. That's the essence of DFS!